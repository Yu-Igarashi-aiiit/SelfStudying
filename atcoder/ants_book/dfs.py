
"""
DFS（深さ優先探索）概要
ある組み合わせ数を全列挙したいときに便利な手法
もしくはある組み合わせからただ一つの解がほしいときの探索手法としても使える（部分和問題）
手法の本質はスタックの全探索

たとえばｎ進数の数え上げがしたいとき
000 001 002 003 004 010 011 012 013 014 020...
１．一番桁数の深いところまで潜り込む
0→0→★
２．この位置から順番にn個数え上げる
000 001 002 003 004 
n = 5 のときn == max なので0→0→★の探索終了
３．一つ探索階層を戻って、同様にその階層からの組み合わせを全列挙
010 011 012 013 014
４．これをすべての階層において n == max となるまで繰り返す

これを任意の組み合わせへ拡張したい場合、
list      = (a,b,c,d,e) :組み合わせしたいパターンを詰め込んだリスト
len(list) = max         :組み合わせられる最大数
とすれば、部分和問題を解くこともできる。

経路探索問題への拡張もできる
list    :　経路選択（←、↑、→、↓）dx = (1,0,-1,0) , dy = (0,1,0,-1)とすると
           for i in range(0,4)で dx[i] or dy[i] で上下左右網羅
pattern : スタート地点からゴール地点までの経路選択履歴
としてどの組み合わせならばゴールにたどり着けるか、
そしてその際のコスト（リストの長さ）を比較することで経路長の評価ができる

"""

#部分和問題
def dfs(i,s):
    
    #終了条件,選べる組み合わせ数の上限が来たら sum==kかどうかのboolean判定
    if i==n:
        return s==k
    
    #何個か選んだときの状態で終了条件へ進む
    if dfs(i+1,s):
        return True
    
    #新たにa[i]を選ぶ
    if dfs(i+1,s+a[i]):
        return True
    return False

def solve():
    if dfs(0,0):
        print("Yes")
    else:
        print("No")

if __name__ == "__main__":
    n = int(input())
    a = list(map(int,input().split()))
    k = int(input())

    solve()

def dfs(A):
    # 数列の長さが N に達したら打ち切り
    if len(A) == N:
        # 処理
        return
    for v in range(M):
        A.append(v)
        dfs(A)
        A.pop()